# node.js
node.js 内存控制 

> Copyright(c) afterloe. ISC Licensed  
> Version: v0.0.5  
> ModifyTime: 2016-12-4 11:07:43  
> Authors:
    afterloe <lm6289511@gmail.com> (https://github.com/afterloe)  
> Host:
    https://github.com/afterloe  

由于v8引擎的限制，在64位机的最大内存使用为1.4G 而 32位机上则是0.7G 内存。前段时间复制的时候最大峰值不超过1.5G  
在程序中可以调用方法查看内存的使用情况
```bash
> process.memoryUsage();
{
	rss: 14958952,
	heapTotal: 7195904,
	heapUsed: 2821496
}
```
其中heapUsed, heapTotal是v8的堆内存使用情况。当我们在代码中申明变量并赋值，当申请的堆空闲内存不足的时候会继续向上申请，直到堆内存大小超过限制。小GC时间大致为50毫秒，非增量式GC则可能超过1秒。rss代表常驻内存空间，进程所占内存分为两部分rss 和 交换区或文件系统  

Buffer 是可以使用堆外内存的，他不经过v8的内存部分，但是大小也是规为即rss的部分  

可以设置node的内存大小
```bash
$ node --max-old-space-size=1700 // 单位为 mb
$ node --max-new-space-size=1024 // 单位为 kb
```

V8垃圾回收机制主要基于分代式垃圾回收机制  
内存在V8中分为年轻代和年老代，年轻代和年老代所采用的回收算法是不一样的。  

年轻代：    
采用的是Scavege算法，Scavege算法将内存分为两块，一块处于使用状态，另外一块空闲。处于使用的状态块也成为from空间，空闲状态的内存块称为to。当进行小规模GC的时候，会扫描from中的内存，找到处于使用存活的对象。也就是被引用的对象，然后复制一份到to内存空间中。然后清除from空间释放内存，最后将to和from两个空间交换。由此实现的内存的回收，Scavege算法的缺点就是只能使用一半的内存。不过在年轻代中是足够了的，因为年轻代的生命周期较短，且时间优异。  
年老代：  
采用的混合算法 Mark-Sweep & Mark-Compact 两个算法共同作用。常用的事Mark-Sweep算法。当进行大GC的时候，先扫描年老代中所有的对象，标记存活的对象也就是被引用的对象。然后开始清除没有被标记的对象，空出不连续的内存该块。这样就能在年老代空出空间供年轻代晋升，不过是有缺陷的。因为使用和被使用是不规则的所以产生的内存碎片大小是不一致的，如果年轻代晋升的对象过大，而Mark-Sweep空出的内存片不够使用的时就会调用Mark-Compact算法，该算法会是Mark-Sweep上进化而来，也是扫描并标记存活对象，删除未被标记的对象。不同的是他会将所有标记的对象移动到一块，将未被标记的对象移动到另外一块，然后一次释放掉所有的未标记对象。这样就能空出一大片相邻的内存块，由于改算法涉及到对象的移动，所以适合Mark-Sweep配合使用，如果内存还是不够晋升，那么就会再次触发一次大GC进行回收。  

晋升：  
当年轻代中的对象经过Scavege算法后没有被回收，或to空间大小超过了25% 就会触发晋升  

由于大GC的过程中采用的算法需要扫描内存会带来停顿，所以v8提供了一种优化，采用了增量标记的策略。然后执行线程和GC线程交替执行。每执行一次标记一次，直到标记段结束，进行回收，这样回收的时间大致可以减少到原本1/6左右，之后还引入了延迟清理和增量清理。  

查看垃圾回收日志
```bash
$ node --trace_gc > gc.log
```

启动V8性能分析数据
```bash
$ node --prof target.js
```

使用分析数据
```bash
$ linux-tick-processor v8.log
```

该脚本在node的源码中deps/v8/tools 中,在windows下则是 windows-tick-processor.bat  

内存释放：  
- 全局变量在线程退出的时候才会被回收
- 采用赋值的方式解除引用 global['foo'] = undefined / null
- 采用delete 方式解除应用(不推荐，会扰乱v8的优化)

内存泄漏的几点
- 缓存
- 队列消费不及时
- 作用域未释放

对于缓存的几点
- 使用内存当缓存，进程是无法共享的，当多核模式的时候会造成某些缓存出现不可避免的重复，是对物理内存的浪费
- 尽量使用外部缓存(redis,Memcached的进程外缓存)，减少进程自生缓存对象，减少常驻内存数量，提高GC回收效率
- 进程之间共享缓存
- 自己实现的话可以参看LRU算法
